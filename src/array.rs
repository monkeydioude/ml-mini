use std::marker::PhantomData;

use ndarray::{Array2, Array};
use rand::{Rng, thread_rng};

pub struct VecBuilder<T: Clone>{
  v: Vec<T>
}

impl<T: Clone> VecBuilder<T> {
  pub fn new() -> Self {
    VecBuilder { v: vec![] }
  }

  pub fn func(occ: usize, func: &mut dyn FnMut() -> T) -> Vec<T> {
    VecBuilder::new().self_func(occ, func)
  }

  pub fn self_func(&mut self, occ: usize, func: &mut dyn FnMut() -> T) -> Vec<T> {
    for _ in 0..occ {
      self.v.push(func());
    }
    self.v.clone()
  }
}

pub struct Array2Random<T> {
  p: PhantomData<T>,
}

macro_rules! impl_array2random {
    () => {};
    ($t:ty) => {
      impl Array2Random<$t> {
        pub fn fill_using_rng(mut prng: impl Rng, shape: (usize, usize)) -> Array2<$t> {
          match Array::from_shape_vec(shape, VecBuilder::func((shape.0 as i32 * shape.1 as i32) as usize, &mut move || -> $t {
            prng.gen()
          })) {
            Ok(r) => r,
            Err(err) => panic!("{}", err),
          }
        }

        pub fn fill(shape: (usize, usize)) -> Array2<$t> {
          Array2Random::<$t>::fill_using_rng(thread_rng(), shape)
        }
      }
    };
    ($t:ty, $($tt:ty,)*) => {
      impl_array2random!($t);
      impl_array2random!($($tt,)*);
  };
}

impl_array2random!(f64, f32, i64, i32,);

#[cfg(test)]
mod tests {
    use ndarray::array;
    use rand::{rngs::StdRng, SeedableRng};

    use crate::array::Array2Random;

  #[test]
  fn test_fill_f64_array2_using_rng() {
    [
      (69, (1, 1), array![[0.011636996469988614]]),
      (69, (2, 1), array![[0.011636996469988614], [0.9680022366322442]]),
      (6969, (10, 10), array![[0.6052055243238758, 0.5256062922464231, 0.15594245384131267, 0.5127845818297203, 0.07691071488354129, 0.9583801512439214, 0.24775519919392697, 0.12780221177894235, 0.7719705120488565, 0.5552590307980454],
      [0.9140495135174803, 0.5212322421649248, 0.7688125985841965, 0.512081985782872, 0.9474368233525242, 0.531557635320995, 0.17483619141646944, 0.2600489436786718, 0.6168603123766887, 0.3175400682230496],
      [0.8163953318230446, 0.04830449464876163, 0.42555085779330026, 0.7556840903651357, 0.4202392046993335, 0.19352352013637353, 0.19017624743916584, 0.005002560223428709, 0.8486948821995149, 0.11479150235198998],
      [0.9607662483117613, 0.6814749229048512, 0.7991857625505476, 0.8170589955322823, 0.33882627243296704, 0.06502102403958121, 0.7558361998257405, 0.4052898598677157, 0.019173728823516756, 0.10130984085274841],
      [0.9081837557040483, 0.5562202372504773, 0.03322981731008812, 0.659565274953054, 0.6905649735230541, 0.1348961715887178, 0.9449441798078896, 0.48907816870544685, 0.738260553613014, 0.378747306570242],
      [0.14700807312808029, 0.6627735050208817, 0.08903665785535408, 0.017754265605710362, 0.24844510169267697, 0.8659704538688993, 0.2276863988858946, 0.9018662671404861, 0.654667313666959, 0.4478764917493667],
      [0.8952493134984175, 0.7180340559360303, 0.5061161593183553, 0.23764415302079378, 0.7194450142031835, 0.7920994071627384, 0.43978609960315573, 0.464435725831709, 0.5074998086494978, 0.4229077331220713],
      [0.11732167567272189, 0.8706255481008462, 0.4891516173217276, 0.9459920219508243, 0.37589324629031917, 0.2421011591833383, 0.9085417149089041, 0.9029531670125359, 0.21380078466527086, 0.2988029516735643],
      [0.355593442562403, 0.918803648054809, 0.5948699987090247, 0.7207052122293376, 0.08404999079027242, 0.714086749280308, 0.9383289970647282, 0.3055809308911801, 0.28796948111551535, 0.9803708520071318],
      [0.04114947361243748, 0.8856249155095721, 0.25168136783243333, 0.28609251180455497, 0.8073680825627968, 0.7937065775019, 0.5375824317476093, 0.9539186474823531, 0.5410187582991586, 0.04075620694619686]]),
    ].iter().for_each(|d| {
      let trial = Array2Random::<f64>::fill_using_rng(StdRng::seed_from_u64(d.0), d.1);
      assert_eq!(trial, d.2);
    });
  }
}